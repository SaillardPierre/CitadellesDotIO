@using CitadellesDotIO.DeckAssembly.EventArgs.Enums
@using CitadellesDotIO.DeckAssembly.Model
@using System.Text
<div class="@OuterClassAttributes" style="@OuterStyleAttribute" id="@Id">
    @Id
    <p>left : @LeftIndex</p>
    <p>right : @RightIndex</p>
    <div class="w-100"
         style="
        display: flex;
        flex-wrap: nowrap;
        justify-content: center;
        align-items: center;
        gap: @(Gap)px;
        border: 1px solid #000;
        overflow-x: visible;
        overflow-y: visible;">
        @{
            int index = 0;
            foreach (Card i in Cards)
            {
                <CardItem Card=i Index=index CssClasses=CardClasses />
                index++;
            }
        }
    </div>
</div>


@code {
    // TODO : Mettre toute la gestion des index / cartes de la liste dans le CardItemList
    [Parameter]
    public List<Card> Cards { get; set; } = new();

    public int? LeftIndex;
    public int? RightIndex;

    [Parameter]
    public string Id { get; set; }

    private int Gap { get; set; } = -10;

    private string OuterStyleAttribute => "display: flex;flex-direction: column;justify-content: center;align-items: center;align-self: center;";
    private string OuterClassAttributes
    {
        get
        {
            StringBuilder stringBuilder = new();
            stringBuilder.Append("w-100 h-100 m-0 ");
            foreach (string cssClass in CssClasses)
            {
                stringBuilder.Append(cssClass).Append(' ');
            }
            if (IsHovered)
            {
                stringBuilder.Append("drop-available ");
                stringBuilder.Append("rz-border-base-300");
            }

            return stringBuilder.ToString();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Task.Delay(1);
            HandleOverlap();
        }
    }


    public bool IsHovered = false;

    public void Reset()
    {
        IsHovered = false;
        LeftIndex = default;
        RightIndex = default;
        foreach (Card card in Cards)
        {
            card.Reset();
        }
        HandleOverlap();
    }
    public void ResetExceptCard(Card exceptCard)
    {
        IsHovered = false;
        LeftIndex = default;
        RightIndex = default;
        foreach (Card card in Cards)
        {
            if (card != exceptCard)
            {
                card.Reset();
            }
        }
        HandleOverlap();
    }
    private void ResetPreviousNeighbours()
    {
        foreach (Card card in Cards)
        {
            bool shouldReset = true;
            // Il s'agit du voisin de gauche
            if (LeftIndex.HasValue && card.Index == LeftIndex.Value)
            {
                shouldReset = false;
            }
            // Il s'agit du voisin de droite
            if (RightIndex.HasValue && card.Index == RightIndex.Value)
            {
                shouldReset = false;
            }
            // Il s'agit de la carte en cours de déplacement
            if (card.IsDragged)
            {
                shouldReset = false;
            }

            if (shouldReset)
            {
                card.Reset();
            }
        }
    }

    public void HandleOverlap()
    {
        // Tentative de comportement par défaut => Premiere carte "dragged"
        int? rightIndex = RightIndex;
        //int? leftIndex = LeftIndex ?? Cards.Count;
        if (!LeftIndex.HasValue)
        {
            if (!RightIndex.HasValue)
            {
                rightIndex = 0;
            }
        }
        else
        {
            // a gauche
            int decrIndex = CardParameters.DraggedCardZIndex;
            for (int i = LeftIndex.Value; i != -1; i--)
            {
                decrIndex--;
                Card target = Cards[i];
                if (!target.IsDragged)
                {
                    target.ZIndex = decrIndex;
                    target.MarginRight = null;
                    target.MarginLeft = $"margin-left:{CardParameters.MarginLeftPercentage}%";
                }
            }
        }
        if (rightIndex.HasValue)
        {
            // a droite
            int decrIndex = CardParameters.DraggedCardZIndex;
            for (int i = rightIndex.Value; i < Cards.Count; i++)
            {
                decrIndex--;
                Card target = Cards[i];
                if (!target.IsDragged)
                {
                    target.ZIndex = decrIndex;
                    target.MarginLeft = null;
                    target.MarginRight = $"margin-right:-{CardParameters.MarginRightPercentage}%";
                }
            }
        }
        StateHasChanged();
    }

    public void HandleHovering(int futureDropIndex, DragHoverTarget dragHoverTarget)
    {
        if (!Cards.Any()) return;
        ResetPreviousNeighbours();

        bool isFirst = futureDropIndex == 0;
        bool isLast = false;

        int? leftIndex = default;
        int? rightIndex = default;

        if (dragHoverTarget == DragHoverTarget.Target)
        {
            isLast = futureDropIndex == Cards.Count;
            if (!isFirst)
            {
                leftIndex = futureDropIndex - 1;
            }
            if (!isLast)
            {
                rightIndex = futureDropIndex;
            }
        }
        else if (dragHoverTarget == DragHoverTarget.Self)
        {
            isLast = futureDropIndex == Cards.Count - 1;
            int draggedItemIndex = Cards.Single(x => x.IsDragged).Index;

            if (!isFirst)
            {
                leftIndex = futureDropIndex - 1;
                // l'item est a droite de son origine
                if (draggedItemIndex < futureDropIndex)
                {
                    leftIndex++;
                }
            }
            if (!isLast)
            {
                rightIndex = futureDropIndex + 1;
                // l'item est a gauche de son origine
                if (draggedItemIndex > futureDropIndex)
                {
                    rightIndex--;
                }
            }
        }

        LeftIndex = leftIndex;
        RightIndex = rightIndex;

        StartNeighboursAnimation();
    }

    private void StartNeighboursAnimation()
    {
        if (!LeftIndex.HasValue && !RightIndex.HasValue)
        {
            string mess = "Aucun index voisin pour l'animation";
            //throw new ArgumentException(mess);
            Console.WriteLine(mess);
            return;
        }

        if (RightIndex.HasValue)
        {
            Card target = Cards[RightIndex.Value];
            target.IsDirectNeighbour = true;
        }

        if (LeftIndex.HasValue)
        {
            Card target = Cards[LeftIndex.Value];
            target.IsDirectNeighbour = true;
        }

    }


    [Parameter]
    public List<string> CssClasses { get; set; } = new() { };

    [Parameter]
    public List<string> CardClasses { get; set; } = new();
}
