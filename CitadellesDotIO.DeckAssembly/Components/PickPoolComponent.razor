@using CitadellesDotIO.DeckAssembly.EventArgs.Enums
@using DeckAssembly.EventArgs
@using DeckAssembly.Model
@using Microsoft.JSInterop;
@using System.Text.RegularExpressions
@using System.Globalization
@inject IJSRuntime JS;

<RadzenStack style="width: 100%; height: 100vh;" JustifyContent="JustifyContent.Stretch" Gap="0px">
    <CardItemList @ref=PickPool Id=@nameof(PickPool) Cards=PickPoolValue CssClasses="new(){PickPoolDropzoneClassName}" CardClasses=cardClasses />
    <RadzenRow style="width: 100%; height: 10vh;min-height:10vh" JustifyContent="JustifyContent.Stretch">

        <p>
            FutureDropIndex :
            <RadzenText Text=@FutureDropIndex.ToString() TextStyle="TextStyle.DisplayH1" />
        </p>
        <p>
            CurrentSource :
            <RadzenText Text=@CurrentSource?.Id.ToString() TextStyle="TextStyle.DisplayH1" />
        </p>
        <p>
            CurrentHoverTarget :
            <RadzenText Text=@CurrentHoverTarget?.Id.ToString() TextStyle="TextStyle.DisplayH1" />
        </p>
    </RadzenRow>
    <CardItemList @ref=PickHand Id=@nameof(PickHand) Cards=PickHandValue CssClasses="new(){PickPoolDropzoneClassName}" CardClasses=cardClasses />
</RadzenStack>

@code {
    private string PickPoolSizeLabel => $"PickPoolSize : {PickPoolValue.Count + PickHandValue.Count}"; private DotNetObjectReference<PickPoolComponent>? blazorComponent;
    private List<string> cardClasses = new() { "pickPoolDraggable" };
    [Parameter]
    public int PickHandLowerThreshold { get; set; }
    [Parameter]
    public int? PickHandUpperThreshold { get; set; }

    [Parameter]
    public List<Card> PickPoolValue { get; set; }
    private CardItemList PickPool { get; set; }

    public List<Card> PickHandValue { get; set; } = new() { new CharacterCard(9, new Engine.DTOs.CharacterDto(1, "Test", null)), new CharacterCard(10, new Engine.DTOs.CharacterDto(1, "Test", null)) };
    private CardItemList PickHand { get; set; }

    private static string PickPoolDropzoneClassName => "pickPoolDropzone";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        

        if (!firstRender)
        {
            return;
        }
       

        blazorComponent = DotNetObjectReference.Create(this);

        await JS.InvokeVoidAsync("setupDraggables", ".pickPoolDraggable", "." + PickPoolDropzoneClassName, blazorComponent);
        await JS.InvokeVoidAsync("setupDropzones", "." + PickPoolDropzoneClassName, blazorComponent);
    }

    private int? FutureDropIndex { get; set; }
    private Card? CurrentCard { get; set; }
    private CardItemList? CurrentSource { get; set; }
    private CardItemList? CurrentHoverTarget { get; set; }

    [JSInvokable(nameof(OnDragStartAsync))]
    public async Task OnDragStartAsync(DragStartEventArgs args)
    {
        CurrentSource = GetTargetPickSource(args.PickSource);
        CurrentCard = CurrentSource.Cards[args.PickIndex];
        FutureDropIndex = args.PickIndex;
    }


    [JSInvokable(nameof(OnDragEndAsync))]
    public async Task OnDragEndAsync(DragEndEventArgs args)
    {
        CurrentCard.Reset();
        CurrentCard = null;
        CurrentSource.Reset();
        CurrentSource = null;
        CurrentHoverTarget.Reset();
        CurrentHoverTarget = null;
        StateHasChanged();
    }

    [JSInvokable(nameof(OnDrop))]
    public async ValueTask OnDrop(DropEventArgs args)
    {
        // A revoir
        if (args.DropEventSource == DropEventSource.Outside)
        {

        }
        if (args.DropEventSource == DropEventSource.Self)
        {
            CurrentSource.Cards.PutBackAtIndex(CurrentCard, FutureDropIndex);
        }
        else if (args.DropEventSource == DropEventSource.Target)
        {
            CardItemList dropDestination = GetTargetPickSource(args.Destination);
            CurrentSource.Cards.Remove(CurrentCard);
            dropDestination.Cards.InsertOrAppend(CurrentCard, FutureDropIndex);
            dropDestination.Reset();
        }
        FutureDropIndex = null;
        StateHasChanged();
    }

    #region A extraire dans un PickPoolManager
    private CardItemList GetTargetPickSource(string pickSourceId)
    {
        if (pickSourceId == nameof(PickPool)) return PickPool;
        if (pickSourceId == nameof(PickHand)) return PickHand;
        else throw new ArgumentException();
    }
    private CardItemList GetOppositePickSource(string pickSourceId)
    {
        if (pickSourceId == nameof(PickPool)) return PickHand;
        if (pickSourceId == nameof(PickHand)) return PickPool;
        else throw new ArgumentException();
    }

    public void UpdateHoveredCardList(DragEnterEventArgs args)
    {
        CardItemList? target = null;
        CardItemList? previous = null;
        if (args.DragHoverTarget == DragHoverTarget.None)
        {
            CurrentSource.ResetExceptCard(CurrentCard);
            previous = GetOppositePickSource(CurrentSource.Id);
        }
        else
        {
            if (args.DragHoverTarget == DragHoverTarget.Target)
            {
                target = GetTargetPickSource(args.HoverSource);
                previous = GetOppositePickSource(args.HoverSource);
            }
            else if (args.DragHoverTarget == DragHoverTarget.Self)
            {
                target = CurrentSource;
            }
        }
        previous?.ResetExceptCard(CurrentCard);
        target!.IsHovered = true;
    }

    [JSInvokable(nameof(OnDragLeave))]
    public async ValueTask OnDragLeave()
    {
        CurrentHoverTarget.ResetExceptCard(CurrentCard);
        CurrentHoverTarget = null;
        StateHasChanged();
    }

    [JSInvokable(nameof(OnDragEnter))]
    public async ValueTask OnDragEnter(DragEnterEventArgs args)
    {
        CurrentHoverTarget = GetTargetPickSource(args.HoverSource);
        UpdateHoveredCardList(args);
        StateHasChanged();
    }

    #endregion
    [JSInvokable(nameof(OnDragMove))]
    public async ValueTask OnDragMove(DragMoveEventArgs args)
    {
        CurrentCard.UpdatePosition(args.DragMoveDirection);
        FutureDropIndex = DragManager.GetFutureIndex(args);
        if (CurrentHoverTarget is not null)
        {
            if (FutureDropIndex.HasValue)
            {
                CurrentHoverTarget.HandleHovering(FutureDropIndex.Value, args.DragHoverTarget);
            }
            CurrentHoverTarget.HandleOverlap();
        }
        else
        {
            PickHand.HandleOverlap();
            PickPool.HandleOverlap();
        }
        StateHasChanged();
    }
}
