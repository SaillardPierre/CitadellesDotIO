@using CitadellesDotIO.DeckAssembly.EventArgs.Enums
@using DeckAssembly.EventArgs
@using DeckAssembly.Model
@using Microsoft.JSInterop;
@using System.Text.RegularExpressions
@using System.Globalization
@inject IJSRuntime JS;

<RadzenStack style="width: 100%; height: 100vh;" class="swapzone" JustifyContent="JustifyContent.Stretch" Gap="0px">
    <RadzenStack class="pickPoolDropzone w-100" style="height: 45vh;" id="@Dropzone.PickPool">
        <RadzenText Text=@PickPoolSizeLabel TextStyle="TextStyle.DisplayH1" />
        <CardItemList ItemList=PickPool CardClasses=cardClasses @ref=PickPoolCardItemList />
    </RadzenStack>
    <RadzenRow style="width: 100%; height: 10vh;">
        <RadzenText Text=@FutureDropIndex.ToString() TextStyle="TextStyle.DisplayH1" />           
    </RadzenRow>
    <RadzenStack class="pickPoolDropzone w-100" style="height: 45vh;" id="@Dropzone.PickHand">
        <CardItemList ItemList=PickHand CardClasses=cardClasses @ref=PickHandCardItemList />
        <RadzenText Text=@PickPoolSizeLabel TextStyle="TextStyle.DisplayH1" />
    </RadzenStack>
</RadzenStack>

@code {
    private string PickPoolSizeLabel => $"PickPoolSize : {PickPool.Count + PickHand.Count}";

    private DotNetObjectReference<PickPoolComponent>? blazorComponent;
    private DotNetObjectReference<DragManager>? dragManager;
    private List<string> cardClasses = new() { "pickPoolDraggable" };

    private CardItemList PickPoolCardItemList;
    private CardItemList PickHandCardItemList;
    private int? FutureDropIndex { get; set; }
    

    [Parameter]
    public int PickHandLowerThreshold { get; set; }
    [Parameter]
    public int? PickHandUpperThreshold { get; set; }

    [Parameter]
    public List<Card> PickPool { get; set; }
    public List<Card> PickHand { get; set; } = new(){ new CharacterCard(9, new Engine.DTOs.CharacterDto(1,"Test",null))};

    private static string PickPoolDropzoneClassName => "pickPoolDropzone";


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        blazorComponent = DotNetObjectReference.Create(this);
        dragManager = DotNetObjectReference.Create(new DragManager());

        await JS.InvokeVoidAsync("setupPickPoolDraggables", ".pickPoolDraggable", "." + PickPoolDropzoneClassName, blazorComponent, dragManager);
        await JS.InvokeVoidAsync("setupPickPoolDropzones", "." + PickPoolDropzoneClassName, blazorComponent);

        // Instancier un PickPoolManager
    }  

    [JSInvokable(nameof(OnDragEndAsync))]
    public async Task OnDragEndAsync(DragEndEventArgs args)
    {
        Card currentDraggedItem = GetCurrentDraggedItem(args.PickIndex, args.PickSource);
        currentDraggedItem.Reset();
        StateHasChanged();
    }

    [JSInvokable(nameof(OnDrop))]
    public async ValueTask OnDrop(DropEventArgs args)
    {
        Card currentDraggedItem = GetCurrentDraggedItem(args.PickIndex, args.PickSource);
        if (currentDraggedItem is null) return;

        // A revoir 

        List<Card> dropDestination = DefineDropDestination(args);
        if (args.DropEventSource == DropEventSource.Self)
        {
            dropDestination.PutBackAtIndex(currentDraggedItem, FutureDropIndex);
        }
        else if (args.DropEventSource == DropEventSource.Target)
        {
            List<Card> source = dropDestination == PickHand ? PickPool : PickHand;
            dropDestination.InsertOrAppend(currentDraggedItem, FutureDropIndex);
            source.Remove(currentDraggedItem);
        }
        currentDraggedItem.Reset();        
        StateHasChanged();
    }


    #region A extraire dans un PickPoolManager
    public List<Card> DefineDropDestination(DropEventArgs args)
    {
        List<Card> destination;
        if (args.Destination == Dropzone.PickHand)
        {
            return PickHand;
        }
        if (args.Destination == Dropzone.PickPool)
        {
            return PickPool;
        }
        throw new ArgumentException("Destination invalide");        
    }

    public Card GetCurrentDraggedItem(int pickIndex, string pickSource)
    {
        // TODO : Ajouter les checks sur l'index
        if (pickSource == Dropzone.PickPool)
        {
            return PickPool[pickIndex];
        }
        else if (pickSource == Dropzone.PickHand)
        {
            return PickHand[pickIndex];
        }
        else throw new ArgumentException();
    }
    public int? GetFutureDropIndex(DragMoveEventArgs args)
    {
        if(args.DragHoverTarget == DragHoverTarget.None)
        {
            return default(int?);
        }
        if (args.DragHoverTarget == DragHoverTarget.Self)
        {
            // TODO : Null checks
            return DragManager.GetFutureIndex(args.DraggablePosition, args.SourceNeighboursPositions);
        }
        if (args.DragHoverTarget == DragHoverTarget.Target)
        {
            // TODO : Null checks
            return DragManager.GetFutureIndex(args.DraggablePosition, args.TargetNeighboursPositions);
        }
        throw new ArgumentOutOfRangeException(nameof(DragHoverTarget) + "invalid in " + nameof(GetFutureDropIndex) + ", value :" + args.DragHoverTarget);
    }

    #endregion
    [JSInvokable(nameof(OnDragMove))]
    public async ValueTask OnDragMove(DragMoveEventArgs args)
    {
        Card currentDraggedItem = GetCurrentDraggedItem(args.PickIndex, args.PickSource);
        // TODO : Extraire l'altération de la card dans un CardManager
        currentDraggedItem.UpdatePosition(args.DraggableMovementPosition);
        //currentDraggedItem.Position = DragManager.UpdatePositionFromMovement(currentDraggedItem.Position, args.DraggableMovementPosition);
        
        FutureDropIndex = GetFutureDropIndex(args);
        StateHasChanged();
    }

    public static class Dropzone
    {
        public const string PickPool = nameof(PickPool);
        public const string PickHand = nameof(PickHand);
    }

}
