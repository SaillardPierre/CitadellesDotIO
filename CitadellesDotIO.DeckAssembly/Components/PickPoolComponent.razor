@using CitadellesDotIO.DeckAssembly.EventArgs.Enums
@using DeckAssembly.EventArgs
@using DeckAssembly.Model
@using Microsoft.JSInterop;
@using System.Text.RegularExpressions
@using System.Globalization
@inject IJSRuntime JS;

<RadzenStack style="width: 100%; height: 100vh;" JustifyContent="JustifyContent.Stretch" Gap="0px">
    <CardItemList @ref=PickPool Id=@nameof(PickPool) Cards=PickPoolValue CssClasses="new(){PickPoolDropzoneClassName}" CardClasses=cardClasses />
    <RadzenRow style="width: 100%; height: 10vh;min-height:10vh" JustifyContent="JustifyContent.Stretch">
       
        <p>
            FutureDropIndex :
            <RadzenText Text=@FutureDropIndex.ToString() TextStyle="TextStyle.DisplayH1" />
        </p>
        <p>
            CurrentSource :
            <RadzenText Text=@CurrentSource?.Id.ToString() TextStyle="TextStyle.DisplayH1" />
        </p>
        <p>
            CurrentHoverTarget :
            <RadzenText Text=@CurrentHoverTarget?.Id.ToString() TextStyle="TextStyle.DisplayH1" />
        </p>
    </RadzenRow>
    <CardItemList @ref=PickHand Id=@nameof(PickHand) Cards=PickHandValue CssClasses="new(){PickPoolDropzoneClassName}" CardClasses=cardClasses />
</RadzenStack>

@code {
    private string PickPoolSizeLabel => $"PickPoolSize : {PickPoolValue.Count + PickHandValue.Count}"; private DotNetObjectReference<PickPoolComponent>? blazorComponent;
    private DotNetObjectReference<DragManager>? dragManager;
    private List<string> cardClasses = new() { "pickPoolDraggable" };
    [Parameter]
    public int PickHandLowerThreshold { get; set; }
    [Parameter]
    public int? PickHandUpperThreshold { get; set; }

    [Parameter]
    public List<Card> PickPoolValue { get; set; }
    private CardItemList PickPool { get; set; }

    public List<Card> PickHandValue { get; set; } = new() { new CharacterCard(9, new Engine.DTOs.CharacterDto(1, "Test", null)), new CharacterCard(10, new Engine.DTOs.CharacterDto(1, "Test", null)) };
    private CardItemList PickHand { get; set; }

    private static string PickPoolDropzoneClassName => "pickPoolDropzone";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        blazorComponent = DotNetObjectReference.Create(this);
        dragManager = DotNetObjectReference.Create(new DragManager());

        await JS.InvokeVoidAsync("setupPickPoolDraggables", ".pickPoolDraggable", "." + PickPoolDropzoneClassName, blazorComponent, dragManager);
        await JS.InvokeVoidAsync("setupPickPoolDropzones", "." + PickPoolDropzoneClassName, blazorComponent);

        // Instancier un PickPoolManager
    }

    private int? FutureDropIndex { get; set; }
    private Card? CurrentCard { get; set; }
    private CardItemList? CurrentSource { get; set; }
    private CardItemList? CurrentHoverTarget { get; set; }

    [JSInvokable(nameof(OnDragStartAsync))]
    public async Task OnDragStartAsync(DragStartEventArgs args)
    {
        CurrentSource = GetTargetPickSource(args.PickSource);
        CurrentCard = CurrentSource.Cards[args.PickIndex];
        FutureDropIndex = args.PickIndex;
    }


    [JSInvokable(nameof(OnDragEndAsync))]
    public async Task OnDragEndAsync(DragEndEventArgs args)
    {
        CurrentCard.Reset();
        CurrentCard = null;
        CurrentSource.Reset();
        CurrentSource = null;
        CurrentHoverTarget.Reset();
        CurrentHoverTarget = null;
        StateHasChanged();
    }

    [JSInvokable(nameof(OnDrop))]
    public async ValueTask OnDrop(DropEventArgs args)
    {
        // A revoir
        if (args.DropEventSource == DropEventSource.Outside)
        {

        }
        if (args.DropEventSource == DropEventSource.Self)
        {
            CurrentSource.Cards.PutBackAtIndex(CurrentCard, FutureDropIndex);
        }
        else if (args.DropEventSource == DropEventSource.Target)
        {
            CardItemList dropDestination = GetTargetPickSource(args.Destination);
            CurrentSource.Cards.Remove(CurrentCard);
            dropDestination.Cards.InsertOrAppend(CurrentCard, FutureDropIndex);
            dropDestination.Reset();
        }
        FutureDropIndex = null;
        StateHasChanged();
    }

    #region A extraire dans un PickPoolManager
    private CardItemList GetTargetPickSource(string pickSourceId)
    {
        if (pickSourceId == nameof(PickPool)) return PickPool;
        if (pickSourceId == nameof(PickHand)) return PickHand;
        else throw new ArgumentException();
    }
    private CardItemList GetOppositePickSource(string pickSourceId)
    {
        if (pickSourceId == nameof(PickPool)) return PickHand;
        if (pickSourceId == nameof(PickHand)) return PickPool;
        else throw new ArgumentException();
    }
    public int? GetFutureDropIndex(DragMoveEventArgs args)
    {
        // A revoir pour ne pas passer les position mais utiliser les references avec CurrentSource et CurrentHoverTarget
        if (args.DragHoverTarget == DragHoverTarget.None)
        {
            //Console.WriteLine("default");
            return default(int?);
        }
        if (args.DragHoverTarget == DragHoverTarget.Self)
        {
            // TODO : Null checks
            int result = DragManager.GetFutureIndex(args.DraggablePosition, args.SourceNeighboursPositions);
            //Console.WriteLine(result);
            return result;
        }
        if (args.DragHoverTarget == DragHoverTarget.Target)
        {
            // TODO : Null checks

            int result = DragManager.GetFutureIndex(args.DraggablePosition, args.TargetNeighboursPositions);
            //Console.WriteLine(result);
            return result;
        }
        throw new ArgumentOutOfRangeException(nameof(DragHoverTarget) + "invalid in " + nameof(GetFutureDropIndex) + ", value :" + args.DragHoverTarget);
    }

    public bool GetIsDirectionIncreasing(Position position)
    {
        bool isIncreasing = false;
        if (position.X < 0)
        {
            // a gauche
        }
        else if (position.X > 0)
        {
            isIncreasing = true;
            // a droite
        };
        return isIncreasing;
    }

    public void UpdateHoveredCardList(DragEnterEventArgs args)
    {
        CardItemList? target = null;
        if (args.DragHoverTarget == DragHoverTarget.None)
        {
            CurrentSource.ResetExceptCard(CurrentCard);
            GetOppositePickSource(CurrentSource.Id).ResetExceptCard(CurrentCard);
            return;
        }
        else if (args.DragHoverTarget == DragHoverTarget.Target)
        {
            target = GetTargetPickSource(args.HoverSource);
        }
        else if (args.DragHoverTarget == DragHoverTarget.Self)
        {
            target = CurrentSource;
        }
        // La main dont on vient de sortir
        CardItemList? previous = GetOppositePickSource(args.HoverSource);
        previous.ResetExceptCard(CurrentCard);
        target!.IsHovered = true;

        // Définition de gauche/droite initiale
        int? leftIndex = default;
        int? rightIndex = default;

        bool isLast = target.Cards.Count == CurrentCard.Index + 1;
        bool isFirst = CurrentCard.Index == 0;

        // On a pris la seule carte
        if (isFirst && isLast)
        {
            return;
        }
        if (!isFirst)
        {
            leftIndex = CurrentCard.Index - 1;
        }
        if (!isLast)
        {
            rightIndex = CurrentCard.Index + 1;
        }

        target.LeftIndex = leftIndex;
        target.RightIndex = rightIndex;
    }

    [JSInvokable(nameof(OnDragEnter))]
    public async ValueTask OnDragEnter(DragEnterEventArgs args)
    {
        CurrentHoverTarget = GetTargetPickSource(args.HoverSource);
        UpdateHoveredCardList(args);
        StateHasChanged();
    }

    #endregion
    [JSInvokable(nameof(OnDragMove))]
    public async ValueTask OnDragMove(DragMoveEventArgs args)
    {
        CurrentCard.UpdatePosition(args.DraggableMovementPosition);
        FutureDropIndex = GetFutureDropIndex(args);
        if (CurrentHoverTarget is not null)
        {
            try
            {
                CurrentHoverTarget.HandleHovering(FutureDropIndex.Value, args.DragHoverTarget);

            }
            catch(Exception ex)
            {
                
            }
        }

        StateHasChanged();
    }
}
