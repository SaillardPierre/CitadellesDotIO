@using CitadellesDotIO.DeckAssembly.EventArgs.DraggableEventArgs
@using CitadellesDotIO.DeckAssembly.EventArgs.Enums
@using CitadellesDotIO.DeckAssembly.Exceptions
@using CitadellesDotIO.DeckAssembly.Model
@using System.Text
@inject IJSRuntime JS;

<CascadingValue Value="this">
    <div class="@OuterClassAttributes" style="@OuterStyleAttribute" id="@Id">
        <RadzenRow>
            <RadzenStack>
                @* <RadzenRow>
                <RadzenCheckBox @bind-Value=@AnchorLeft />
                Anchor Left
                </RadzenRow>
                <RadzenRow>
                <RadzenCheckBox @bind-Value=@AnchorRight />
                Anchor Right
                </RadzenRow>
                </RadzenStack>
                <RadzenStack>
                <RadzenRow>
                Base Transform Ratio
                <RadzenNumeric @bind-Value=@BaseTransformRatio />
                </RadzenRow> *@
                <RadzenRow>
                    Has draghover : @(IsDragHoverTarget ? "True" : "False")
                    <RadzenText />
                </RadzenRow>
                <RadzenRow>
                    Has Dragged Card : @(DraggedCard is not null ? "True" : "False")
                    <RadzenText />
                </RadzenRow>
                <RadzenRow>
                    Has Hovered Card : @(HoveredCard is not null ? "True" : "False")
                    <RadzenText />
                </RadzenRow>
            </RadzenStack>
            <RadzenStack>
                <RadzenRow>
                    Left : @LeftIndex
                </RadzenRow>
                <RadzenRow>
                    Right : @RightIndex
                </RadzenRow>
                <RadzenRow>
                    FutureDropIndex : @FutureDropIndex
                </RadzenRow>
            </RadzenStack>
        </RadzenRow>
        @Id
        <div class="w-100"
             style="
        display: flex;
        flex-wrap: nowrap;
        justify-content: center;
        align-items: center;
        border: 1px solid #000;
        overflow-x: visible;
        overflow-y: visible;">
            @{
                int index = 0;
                foreach (Card i in Cards)
                {
                    i.Index = index;
                    <CardComponent Card=i />
                    index++;
                }
            }
        </div>
    </div>
</CascadingValue>
@code {
    private bool _shouldRender = true;
    protected override bool ShouldRender()
    {
        return _shouldRender;
    }
    public void PreventRender()
    {
        _shouldRender = false;
    }
    public void AllowRender()
    {
        _shouldRender = true;
    }
    [Parameter]
    public string Id { get; set; }

    [CascadingParameter] CardsContainer Container { get; set; }

    [Parameter, EditorRequired]
    public List<Card> Cards { get; set; }

    private List<CardComponent> CardComponents { get; set; } = new();

    private DotNetObjectReference<CardListComponent>? self;

    private int? FutureDropIndex { get; set; }
    private int? LeftIndex { get; set; }
    private int? RightIndex { get; set; }

    private Card? HoveredCard { get; set; }
    private Card? DraggedCard { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            self = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("setupDropzoneById", Id, '.' + DropzoneParameters.ClassName, self);
        }
    }

    protected override void OnParametersSet()
    {
        StateException.ThrowIfNull(Cards, nameof(Cards));
        StateException.ThrowIfNull(Container, nameof(Container));
    }
    #region Draggables Events
    public void OnDraggableHoverStart(int cardIndex)
    {
        if (DraggedCard is not null) return;
        StateException.ThrowIfNotNull(HoveredCard);
        HoveredCard = Cards[cardIndex];
        StateException.ThrowIfNull(HoveredCard);
        (LeftIndex, RightIndex) = DragManager.ComputeLeftRightIndexes(cardIndex, Cards.Count, DragHoverTarget.Self);
        StateHasChanged();
    }

    public void OnDraggableHoverEnd()
    {
        if (DraggedCard is not null) return;
        StateException.ThrowIfNull(HoveredCard);
        LeftIndex = default;
        RightIndex = default;
        HoveredCard = null;
        StateHasChanged();
    }

    public void OnDraggableMove(DraggableMoveEventArgs args)
    {
        DraggedCard = Cards[args.DraggableIndex];
        (LeftIndex, RightIndex) = DragManager.ComputeLeftRightIndexes(args.DraggableIndex, Cards.Count, DragHoverTarget.Self);
        // TODO : Bug a régler ici, a voir plus tard
        FutureDropIndex = DragManager.GetFutureIndex(args.DragHoverTarget, DraggedCard.Position, Cards.Select(x => x.Position));
        // if(args.DragHoverTarget == DragHoverTarget.Self)
        // {
        DragManager.SetOverlapFromIndexes(Cards, LeftIndex, RightIndex);
        // }
        Container.OnDraggableMove(args);
        StateHasChanged();
    }

    public async void OnDraggableDragStart(int cardIndex)
    {
        StateException.ThrowIfNotNull(DraggedCard);
        DraggedCard = Cards[cardIndex];
        FutureDropIndex = cardIndex;
        IsHovered = true;
        StateException.ThrowIfNull(DraggedCard);
        DraggableDragStartEventArgs args = new(cardIndex, Id);
        Container.OnDraggableDragStart(args);
        StateHasChanged();
    }

    public void OnDraggableDragEnd()
    {
        bool putBack = true;

        StateException.ThrowIfNull(DraggedCard, nameof(DraggedCard));
        // TODO : Ici peut être appliquer les refs en dico comme dans le CardsContainer pour StateHasChanged() l'element enfant
        if (putBack)
        {
            DraggedCard.Reset();
        }
        if (IsDragHoverTarget)
        {
            IsDragHoverTarget = false;
        }
        DraggedCard = null;
        FutureDropIndex = null;
        StateHasChanged();
        Container.OnDraggableDragEnd();
    }
    #endregion

    [JSInvokable(nameof(OnDraggableDropzoneEnter))]
    public void OnDraggableDropzoneEnter(DraggableDropzoneEnterEventArgs args)
    {
        InvalidEnumException.ThrowIfEqual<DragHoverTarget>(args.DragHoverTarget, DragHoverTarget.None);
        if (args.DragHoverTarget == DragHoverTarget.Self)
        {
            if (args.DropzoneHoverSource == this.Id)
            {
                // Faire le traitement sur la cardItemList
                this.ToggleDragHover(true);
            }
            else
            {
                // Pas normal ca
            }
        }
        Container.OnDraggableDropzoneEnter(args);
    }

    [JSInvokable(nameof(OnDraggableDropzoneLeave))]
    public void OnDraggableDropzoneLeave(DraggableDropzoneLeaveEventArgs args)
    {
        this.ToggleDragHover(false);
        Container.OnDraggableDropzoneLeave(args);
    }

    private bool IsDragHoverTarget;
    public void ToggleDragHover(bool isDragHoverTarget)
    {
        this.IsDragHoverTarget = isDragHoverTarget;
        StateHasChanged();
    }
    private async Task HandleDrop()
    {
    }
    private string OuterStyleAttribute => "display: flex;flex-direction: column;justify-content: center;align-items: center;align-self: center;";
    private bool AnchorLeft { get; set; }
    private bool AnchorRight { get; set; }
    private int BaseTransformRatio { get; set; }
    private bool IsHovered = false;

    private string OuterClassAttributes
    {
        get
        {
            StringBuilder stringBuilder = new();
            stringBuilder.Append(DropzoneParameters.ClassName);
            stringBuilder.Append(" w-100 h-100 m-0 ");
            foreach (string cssClass in CssClasses)
            {
                stringBuilder.Append(cssClass).Append(' ');
            }
            if (IsHovered)
            {
                stringBuilder.Append("drop-available ");
                stringBuilder.Append("rz-border-base-300");
            }

            return stringBuilder.ToString();
        }
    }


    [Parameter]
    public List<string> CssClasses { get; set; } = new() { };

    [Parameter]
    public List<string> CardClasses { get; set; } = new();

}
