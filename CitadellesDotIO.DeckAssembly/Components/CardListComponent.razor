@using CitadellesDotIO.DeckAssembly.EventArgs.DraggableEventArgs
@using CitadellesDotIO.DeckAssembly.EventArgs.Enums
@using CitadellesDotIO.DeckAssembly.Exceptions
@using CitadellesDotIO.DeckAssembly.Model
@using System.Text
@inject IJSRuntime JS;

<CascadingValue Value="this">
    <div class="@OuterClassAttributes" style="@OuterStyleAttribute" id="@Id">
        <RadzenRow>
            <RadzenStack>
                <RadzenRow>
                    <RadzenCheckBox @bind-Value=@AnchorLeft />
                    Anchor Left
                </RadzenRow>
                <RadzenRow>
                    <RadzenCheckBox @bind-Value=@AnchorRight />
                    Anchor Right
                </RadzenRow>
            </RadzenStack>
            <RadzenStack>
                <RadzenRow>
                    Base Transform Ratio
                    <RadzenNumeric @bind-Value=@BaseTransformRatio />
                </RadzenRow>
            </RadzenStack>
            <RadzenStack>
                <RadzenRow>
                    Left : @LeftIndex
                </RadzenRow>
                <RadzenRow>
                    Right : @RightIndex
                </RadzenRow>
                <RadzenRow>
                    FutureDropIndex : @FutureDropIndex
                </RadzenRow>
            </RadzenStack>
        </RadzenRow>
        @Id
        <div class="w-100"
             style="
        display: flex;
        flex-wrap: nowrap;
        justify-content: center;
        align-items: center;
        border: 1px solid #000;
        overflow-x: visible;
        overflow-y: visible;">
            @{
                int index = 0;
                foreach (Card i in Cards)
                {
                    i.Index = index;
                    <CardComponent Card=i />
                    index++;
                }
                // // Ne fonctionne pas, pas très grave pour l'instnat
                // foreach (CardComponent cardComponent in CardComponents)
                // {
                //     @cardComponent
                // }
            }
        </div>
    </div>
</CascadingValue>
@code {
    [Parameter]
    public string Id { get; set; }

    [CascadingParameter] CardsContainer Container { get; set; }

    [Parameter, EditorRequired]
    public List<Card> Cards { get; set; }

    private List<CardComponent> CardComponents { get; set; } = new();

    private DotNetObjectReference<CardListComponent>? self;

    private int? FutureDropIndex { get; set; }
    private int? LeftIndex { get; set; }
    private int? RightIndex { get; set; }

    private Card? HoveredCard { get; set; }
    private Card? DraggedCard { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            self = DotNetObjectReference.Create(this);
            // TODO : Faire un setupDropzonesById() dans le JS pour invoker les evenments depuis interact coté dropzone
            //await JS.InvokeVoidAsync("setupDraggableById", CardId, ".futureDropzoneClassName", self);
        }
    }

    protected override void OnParametersSet()
    {
        StateException.ThrowIfNull(Cards, nameof(Cards));
        StateException.ThrowIfNull(Container, nameof(Container));
    }

    public void OnDraggableHoverStart(int cardIndex)
    {
        if (DraggedCard is not null) return;
        StateException.ThrowIfNotNull(HoveredCard);
        HoveredCard = Cards[cardIndex];
        StateException.ThrowIfNull(HoveredCard);
        (LeftIndex, RightIndex) = DragManager.ComputeLeftRightIndexes(cardIndex, Cards.Count, DragHoverTarget.Self);
        StateHasChanged();
    }

    public void OnDraggableHoverEnd()
    {
        if (DraggedCard is not null) return;
        StateException.ThrowIfNull(HoveredCard);
        LeftIndex = default;
        RightIndex = default;
        HoveredCard = null;
        StateHasChanged();
    }

    public void OnDraggableMove(DraggableMoveEventArgs args)
    {
        DraggedCard = Cards[args.DraggableIndex];
        (LeftIndex, RightIndex) = DragManager.ComputeLeftRightIndexes(args.DraggableIndex, Cards.Count, DragHoverTarget.Self);
        // TODO : Bug a régler ici, a voir plus tard
        FutureDropIndex = DragManager.GetFutureIndex(args.DragHoverTarget, DraggedCard.Position, Cards.Select(x => x.Position));
        // if(args.DragHoverTarget == DragHoverTarget.Self)
        // {
        DragManager.SetOverlapFromIndexes(Cards, LeftIndex, RightIndex);
        // }
        Container.OnDraggableMove(args);
        StateHasChanged();
    }

    public async void OnDraggableDragStart(int cardIndex)
    {
        StateException.ThrowIfNotNull(DraggedCard);
        DraggedCard = Cards[cardIndex];
        FutureDropIndex = cardIndex;
        IsHovered = true;
        StateException.ThrowIfNull(DraggedCard);
        DraggableDragStartEventArgs args = new(cardIndex, Id);
        Container.OnDraggableDragStart(args);
    }

    public void OnDraggableDragEnd()
    {
        bool putBack = true;

        StateException.ThrowIfNull(DraggedCard, nameof(DraggedCard));
        if (putBack)
        {
            DraggedCard.Reset();
        }
        DraggedCard = null;
        FutureDropIndex = null;
        Container.OnDraggableDragEnd();
    }

    // TODO : Besoin de gérer ca pour le args.DragHoverTarget
    private void HandleDragEnter()
    {
    }

    private void HandleDragLeave()
    {
    }

    private async Task HandleDrop()
    {
    }
    private string OuterStyleAttribute => "display: flex;flex-direction: column;justify-content: center;align-items: center;align-self: center;";
    private bool AnchorLeft { get; set; }
    private bool AnchorRight { get; set; }
    private int BaseTransformRatio { get; set; }
    private bool IsHovered = false;

    private string OuterClassAttributes
    {
        get
        {
            StringBuilder stringBuilder = new();
            stringBuilder.Append("w-100 h-100 m-0 ");
            foreach (string cssClass in CssClasses)
            {
                stringBuilder.Append(cssClass).Append(' ');
            }
            if (IsHovered)
            {
                stringBuilder.Append("drop-available ");
                stringBuilder.Append("rz-border-base-300");
            }

            return stringBuilder.ToString();
        }
    }


    [Parameter]
    public List<string> CssClasses { get; set; } = new() { };

    [Parameter]
    public List<string> CardClasses { get; set; } = new();

}
